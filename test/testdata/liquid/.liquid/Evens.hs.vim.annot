1:1-1:1::Main.$trModule :: "GHC.Types.Module"
6:1-6:10::Main.weAreEven :: "[{v : GHC.Types.Int | v mod 2 == 0}]"
6:19-6:23::lq_anf$##7205759403792802156 :: "GHC.Types.Int"
6:20-6:21::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
6:27-6:30::lq_anf$##7205759403792802159 :: "GHC.Types.Int"
6:28-6:29::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
9:1-9:8::Main.notEven :: "{v : GHC.Types.Int | v mod 2 == 0}"
13:1-13:7::Main.isEven :: "x1:{v : GHC.Types.Int | v >= 0} -> {v : GHC.Types.Bool | v <=> x1 mod 2 == 0}"
15:12-15:15::_ :: "{v : x1:GHC.Types.Bool -> {v : GHC.Types.Bool | v <=> not x1} | v == GHC.Classes.not}"
15:17-15:23::Main.isEven :: "x1:{v : GHC.Types.Int | v >= 0} -> {v : GHC.Types.Bool | v <=> x1 mod 2 == 0}"
15:25-15:28::lq_anf$##7205759403792802146 :: "GHC.Types.Int"
15:26-15:27::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 - x2}"
18:1-18:6::Main.evens :: "{v : GHC.Types.Int | v >= 0} -> [{v : GHC.Types.Int | v mod 2 == 0}]"
18:7-18:8::n :: "{v : GHC.Types.Int | v >= 0}"
18:11-18:41::lq_anf$##7205759403792802151 :: "{VV : [{VV : GHC.Types.Int | VV /= n\n                             && VV <= n\n                             && VV < n\n                             && VV >= 0\n                             && VV mod 2 == 0}] | len VV >= 0}"
18:21-18:26::_ :: "{v : x1:GHC.Types.Int -> x2:GHC.Types.Int -> [{v : GHC.Types.Int | x1 <= v\n                                                                   && v < x2}] | v == Main.range}"
18:32-18:38::_ :: "{v : x1:{v : GHC.Types.Int | v >= 0} -> {v : GHC.Types.Bool | v <=> x1 mod 2 == 0} | v == Main.isEven}"
21:1-21:6::Main.range :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> [{v : GHC.Types.Int | x1 <= v\n                                                              && v < x2}]"
21:7-21:9::lo :: "GHC.Types.Int"
21:10-21:12::hi :: "GHC.Types.Int"
22:5-22:12::lq_anf$##7205759403792802138 :: "{v : GHC.Types.Bool | v <=> lo < hi}"
22:8-22:9::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Bool | v <=> x1 < x2}"
22:22-22:27::Main.range :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> [{v : GHC.Types.Int | x1 <= v\n                                                              && v < x2}]"
22:29-22:33::lq_anf$##7205759403792802141 :: "GHC.Types.Int"
22:31-22:32::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 + x2}"
26:1-26:6::Main.shift :: "[{v : GHC.Types.Int | v mod 2 == 0}] -> {v : GHC.Types.Int | v mod 2 == 0} -> [{v : GHC.Types.Int | v mod 2 == 0}]"
26:7-26:9::xs :: "[{v : GHC.Types.Int | v mod 2 == 0}]"
26:10-26:11::k :: "{v : GHC.Types.Int | v mod 2 == 0}"
26:14-26:31::lq_anf$##7205759403792802137 :: "{VV : [{VV : GHC.Types.Int | VV mod 2 == 0}] | len VV <= len xs\n                                               && len VV >= 0}"
26:15-26:20::lq_anf$##7205759403792802136 :: "GHC.Types.Int"
26:17-26:18::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 + x2}"
29:1-29:7::Main.double :: "[{v : GHC.Types.Int | v >= 0}] -> [{v : GHC.Types.Int | v mod 2 == 0}]"
29:8-29:10::xs :: "[{v : GHC.Types.Int | v >= 0}]"
29:13-29:30::lq_anf$##7205759403792802134 :: "{VV : [{VV : GHC.Types.Int | VV >= 0\n                             && VV mod 2 == 0}] | len VV <= len xs\n                                                  && len VV >= 0}"
29:14-29:19::lq_anf$##7205759403792802133 :: "GHC.Types.Int"
29:16-29:17::_ :: "x1:GHC.Types.Int -> x2:GHC.Types.Int -> {v : GHC.Types.Int | v == x1 + x2}"
41:1-41:5:::Main.main :: "(GHC.Types.IO ())"
41:8-41:16::_ :: "{v : [GHC.Types.Char] -> (GHC.Types.IO ()) | v == System.IO.putStrLn}"